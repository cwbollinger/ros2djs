<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<script src="https://static.robotwebtools.org/EaselJS/current/easeljs.js"></script>
<script src="https://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
<script src="https://static.robotwebtools.org/roslibjs/current/roslib.js"></script>
<script src="../build/ros2d.js"></script>

<script>
  /**
   * Setup all visualization elements when the page is loaded.
   */

  class LabeledMarker {
    constructor(robotName, color, size=1) {
      this.name = robotName;
      this.color = color;
      this.size = size;
      this.marker_width = size;
      this.marker_height = size;
      this.graphic = null;
      this.scalingFactor = 0.1;
    }

    updateScaling(scaleX, scaleY) {
      this.marker_width = this.size/scaleX;
      this.marker_height = this.size/scaleY;
      let graphic = new createjs.Graphics();
      graphic.setStrokeStyle(1);
      graphic.beginFill(createjs.Graphics.getRGB(255,0,0));
      graphic.drawEllipse(-this.marker_width/2,-this.marker_height/2,this.marker_width,this.marker_height);
      this.marker = new createjs.Shape(graphic);
      this.markerText = new createjs.Text(this.name, '12px Arial', this.color);
      let bounds = this.markerText.getBounds();
      this.markerText.setTransform(this.markerText.x-this.scalingFactor*bounds.width/2, this.markerText.y-this.scalingFactor*bounds.height, this.scalingFactor, this.scalingFactor);
    }

    setLocation(x, y, theta=0) {
      this.marker.x = x;
      this.marker.y = y;
      this.marker.rotation = theta;
      let bounds = this.markerText.getTransformedBounds();
      this.markerText.setTransform(x-bounds.width/2, y-bounds.height, this.scalingFactor, this.scalingFactor);
    }

    addMarker(viewer) {
      this.updateScaling(viewer.scene.scaleX, viewer.scene.scaleY);
      viewer.addObject(this.marker);
      viewer.addObject(this.markerText);
    }
  } 

  class RobotVisualizer {
    constructor(ros, prefixName) {
      this.prefixName = prefixName
      this.nav_topic = new ROSLIB.Topic({
        ros : ros,
        name : prefixName+'/move_base_simple/goal',
        messageType : 'geometry_msgs/PoseStamped'
      });

      this.nav_goal_topic = new ROSLIB.Topic({
        ros : ros,
        name : prefixName+'/move_base/current_goal',
        messageType : 'geometry_msgs/PoseStamped'
      });
    }
  }

  let markers = [];

  function init() {
    // Connect to ROS.
    var ros = new ROSLIB.Ros({
      url : 'ws://olorin.engr.oregonstate.edu:9090'
    });

    // Create the main viewer.
    var viewer = new ROS2D.Viewer({
      divID : 'map',
      width : 600,
      height : 600
    });

    // Setup the map client.
    var gridClient = new ROS2D.OccupancyGridClient({
      ros : ros,
      rootObject : viewer.scene,
      // Use this property in case of continuous updates			
      continuous: true
    });

    // Scale the canvas to fit to the map
    gridClient.on('change', function() {
      viewer.scaleToDimensions(gridClient.currentGrid.width, gridClient.currentGrid.height);
      viewer.shift(gridClient.currentGrid.pose.position.x, gridClient.currentGrid.pose.position.y);
      for(let m of markers) {
        m.updateScaling(viewer.scene.scaleX, viewer.scene.scaleY);
      }
    });

    let marker = new LabeledMarker('fetch', 'red', 0.5);
    //markers.push(marker);
    marker.addMarker(viewer);

    console.log("creating TFClient");
    var tfClient = new ROSLIB.TFClient({
      ros : ros,
      fixedFrame : '/map',
      angularThres : 0.01,
      transThres : 0.01
    });

    tfClient.subscribe('base_link', function(tf) {
      marker.setLocation(tf.translation.x, -tf.translation.y);
    });

    function transformClickToMap(pixelX, pixelY) {
      x_offset = gridClient.currentGrid.pose.position.x;
      y_offset = gridClient.currentGrid.pose.position.y;
      //console.log(gridClient.currentGrid.pose);
      console.log('Pixel Coordinates');
      console.log(pixelX + ', ' + pixelY);
      //console.log('Scaled Coordinates');
      //console.log(evt.stageX/viewer.scene.scaleX + ', ' + evt.stageY/viewer.scene.scaleY);
      //console.log('Offset');
      //console.log(x_offset + ', ' + y_offset);
      x_map = pixelX/viewer.scene.scaleX+x_offset;
      y_map = pixelY/viewer.scene.scaleY+y_offset;
      //console.log('Transformed click coordinates');
      //console.log(x_click_map + ', ' +  y_click_map);
      return [x_map, y_map];
    }

    var nav_goal = null;
    var nav_marker_width=0;
    var nav_marker_height=0;

    function showNavGoal(msg) {
      console.log('Message Position:');
      console.log(msg.pose.position);
      //x_offset = gridClient.currentGrid.pose.position.x;
      //y_offset = gridClient.currentGrid.pose.position.y;
      //console.log('GridClient pose:');
      //console.log(gridClient.currentGrid.pose.position);
      //console.log('Pixel Coordinates');
      //console.log(evt.stageX + ', ' + evt.stageY);
      //console.log('Scaled Coordinates');
      //console.log(evt.stageX/viewer.scene.scaleX + ', ' + evt.stageY/viewer.scene.scaleY);
      //console.log('Offset');
      //console.log(x_offset + ', ' + y_offset);
      //console.log('Viewer Scale:');
      //console.log(viewer.scene.scaleX);
      //console.log(viewer.scene.scaleY);
      //console.log('Transformed click coordinates');
      //console.log(x_click_map + ', ' +  y_click_map);
      if(nav_goal == null) {
        var dot_graphic = new createjs.Graphics();
        dot_graphic.setStrokeStyle(1);
        dot_graphic.beginFill(createjs.Graphics.getRGB(0,255,0));
        nav_marker_width = 20/viewer.scene.scaleX;
        nav_marker_height = 20/viewer.scene.scaleY;
        dot_graphic.drawEllipse(-nav_marker_width/2,-nav_marker_height/2,nav_marker_width,nav_marker_height);
        nav_goal = new createjs.Shape(dot_graphic);
        viewer.addObject(nav_goal);
      }
      nav_goal.x = msg.pose.position.x;
      nav_goal.y = -msg.pose.position.y;
    }

    nav_goal_topic.subscribe(showNavGoal);

    var s = null;
    var marker_width=0;
    var marker_height=0;

    function handleClick(evt) {
      console.log(evt);
      map_point = transformClickToMap(evt.stageX, evt.stageY);
      console.log(map_point[0] + ', ' +  map_point[1]);

      if(s == null) {
        var dot_graphic = new createjs.Graphics();
        dot_graphic.setStrokeStyle(1);
        dot_graphic.beginFill(createjs.Graphics.getRGB(0,0,255));
        marker_width = 10/viewer.scene.scaleX;
        marker_height = 10/viewer.scene.scaleY;
        dot_graphic.drawEllipse(-marker_width/2,-marker_height/2,marker_width,marker_height);
        s = new createjs.Shape(dot_graphic);
        viewer.addObject(s);
      }

      s.x = map_point[0];
      s.y = map_point[1];

      nav_topic.publish(new ROSLIB.Message({
        header: {
          frame_id: 'map'
        },
        pose: {
          position: {
            x: map_point[0],
            y: map_point[1],
            z: 0.0
          },
          orientation: {
            x: 0.0,
            y: 0.0,
            z: 0.0,
            w: 1.0
          }
        }
      }));
    }

    viewer.scene.on("stagemousedown", handleClick);
  }
</script>
</head>

<body onload="init()">
  <h1>Continuous Map Example</h1>
  <p>
    Use any method to publish continuous updates to topic /map and use this page to visualize updates. Follow these commands:
  </p>
  <ol>
    <li><tt>roscore</tt></li>
    <li><tt>(method of choice to publish to /map)</tt></li>
    <li><tt>roslaunch rosbridge_server rosbridge_websocket.launch</tt></li>
  </ol>
  <div id="map"></div>
</body>
</html>
